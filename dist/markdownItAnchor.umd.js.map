{"version":3,"file":"markdownItAnchor.umd.js","sources":["../index.js"],"sourcesContent":["const slugify = (s) => encodeURIComponent(String(s).trim().toLowerCase().replace(/\\s+/g, '-'))\n\nconst position = {\n  false: 'push',\n  true: 'unshift'\n}\n\nconst hasProp = Object.prototype.hasOwnProperty\n\nconst permalinkHref = slug => `#${slug}`\nconst permalinkAttrs = slug => ({})\n\nconst renderPermalink = (slug, opts, state, idx) => {\n  const space = () => Object.assign(new state.Token('text', '', 0), { content: ' ' })\n\n  const linkTokens = [\n    Object.assign(new state.Token('link_open', 'a', 1), {\n      attrs: [\n        ...(opts.permalinkClass ? [['class', opts.permalinkClass]] : []),\n        ['href', opts.permalinkHref(slug, state)],\n        ...Object.entries(opts.permalinkAttrs(slug, state))\n      ]\n    }),\n    Object.assign(new state.Token('html_block', '', 0), { content: opts.permalinkSymbol }),\n    new state.Token('link_close', 'a', -1)\n  ]\n\n  // `push` or `unshift` according to position option.\n  // Space is at the opposite side.\n  if (opts.permalinkSpace) {\n    linkTokens[position[!opts.permalinkBefore]](space())\n  }\n  state.tokens[idx + 1].children[position[opts.permalinkBefore]](...linkTokens)\n}\n\nconst uniqueSlug = (slug, slugs, failOnNonUnique, startIndex) => {\n  let uniq = slug\n  let i = startIndex\n  if (failOnNonUnique && hasProp.call(slugs, uniq)) {\n    throw Error(`User defined id attribute '${slug}' is NOT unique. Please fix it in your markdown to continue.`)\n  } else {\n    while (hasProp.call(slugs, uniq)) uniq = `${slug}-${i++}`\n  }\n  slugs[uniq] = true\n  return uniq\n}\n\nconst isLevelSelectedNumber = selection => level => level >= selection\nconst isLevelSelectedArray = selection => level => selection.includes(level)\n\nconst anchor = (md, opts) => {\n  opts = Object.assign({}, anchor.defaults, opts)\n\n  md.core.ruler.push('anchor', state => {\n    const slugs = {}\n    const tokens = state.tokens\n\n    const isLevelSelected = Array.isArray(opts.level)\n      ? isLevelSelectedArray(opts.level)\n      : isLevelSelectedNumber(opts.level)\n\n    tokens\n      .filter(token => token.type === 'heading_open')\n      .filter(token => isLevelSelected(Number(token.tag.substr(1))))\n      .forEach(token => {\n        // Aggregate the next token children text.\n        const title = tokens[tokens.indexOf(token) + 1]\n          .children\n          .filter(token => token.type === 'text' || token.type === 'code_inline')\n          .reduce((acc, t) => acc + t.content, '')\n\n        let slug = token.attrGet('id')\n\n        if (slug == null) {\n          slug = uniqueSlug(opts.slugify(title), slugs, false, opts.uniqueSlugStartIndex)\n        } else {\n          slug = uniqueSlug(slug, slugs, true, opts.uniqueSlugStartIndex)\n        }\n        token.attrSet('id', slug)\n\n        if (opts.permalink) {\n          opts.renderPermalink(slug, opts, state, tokens.indexOf(token))\n        }\n\n        if (opts.callback) {\n          opts.callback(token, { slug, title })\n        }\n      })\n  })\n}\n\nanchor.defaults = {\n  level: 1,\n  slugify,\n  uniqueSlugStartIndex: 1,\n  permalink: false,\n  renderPermalink,\n  permalinkClass: 'header-anchor',\n  permalinkSpace: true,\n  permalinkSymbol: 'Â¶',\n  permalinkBefore: false,\n  permalinkHref,\n  permalinkAttrs\n}\n\nexport default anchor\n"],"names":["position","false","true","hasProp","Object","prototype","hasOwnProperty","uniqueSlug","slug","slugs","failOnNonUnique","startIndex","uniq","i","call","Error","anchor","md","opts","assign","defaults","core","ruler","push","state","selection","tokens","isLevelSelected","Array","isArray","level","includes","isLevelSelectedNumber","filter","token","type","Number","tag","substr","forEach","title","indexOf","children","reduce","acc","t","content","attrGet","slugify","uniqueSlugStartIndex","attrSet","permalink","renderPermalink","callback","s","encodeURIComponent","String","trim","toLowerCase","replace","idx","linkTokens","Token","attrs","permalinkClass","permalinkHref","entries","permalinkAttrs","permalinkSymbol","permalinkSpace","permalinkBefore"],"mappings":"yLAAA,IAEMA,EAAW,CACfC,MAAO,OACPC,KAAM,WAGFC,EAAUC,OAAOC,UAAUC,eA4B3BC,EAAa,SAACC,EAAMC,EAAOC,EAAiBC,GAChD,IAAIC,EAAOJ,EACPK,EAAIF,EACR,GAAID,GAAmBP,EAAQW,KAAKL,EAAOG,GACzC,MAAMG,oCAAoCP,kEAE1C,KAAOL,EAAQW,KAAKL,EAAOG,IAAOA,EAAUJ,MAAQK,IAGtD,OADAJ,EAAMG,IAAQ,EACPA,GAMHI,EAAS,SAATA,EAAUC,EAAIC,GAClBA,EAAOd,OAAOe,OAAO,GAAIH,EAAOI,SAAUF,GAE1CD,EAAGI,KAAKC,MAAMC,KAAK,SAAU,SAAAC,GAC3B,IANyBC,EAMnBhB,EAAQ,GACRiB,EAASF,EAAME,OAEfC,EAAkBC,MAAMC,QAAQX,EAAKY,QATlBL,EAUAP,EAAKY,eAVQA,UAASL,EAAUM,SAASD,KADxC,SAAAL,mBAAaK,UAASA,GAASL,GAYrDO,CAAsBd,EAAKY,OAE/BJ,EACGO,OAAO,SAAAC,SAAwB,iBAAfA,EAAMC,OACtBF,OAAO,SAAAC,UAASP,EAAgBS,OAAOF,EAAMG,IAAIC,OAAO,OACxDC,QAAQ,SAAAL,GAEP,IAAMM,EAAQd,EAAOA,EAAOe,QAAQP,GAAS,GAC1CQ,SACAT,OAAO,SAAAC,SAAwB,SAAfA,EAAMC,MAAkC,gBAAfD,EAAMC,OAC/CQ,OAAO,SAACC,EAAKC,UAAMD,EAAMC,EAAEC,SAAS,IAEnCtC,EAAO0B,EAAMa,QAAQ,MAGvBvC,EADU,MAARA,EACKD,EAAWW,EAAK8B,QAAQR,GAAQ/B,GAAO,EAAOS,EAAK+B,sBAEnD1C,EAAWC,EAAMC,GAAO,EAAMS,EAAK+B,sBAE5Cf,EAAMgB,QAAQ,KAAM1C,GAEhBU,EAAKiC,WACPjC,EAAKkC,gBAAgB5C,EAAMU,EAAMM,EAAOE,EAAOe,QAAQP,IAGrDhB,EAAKmC,UACPnC,EAAKmC,SAASnB,EAAO,CAAE1B,KAAAA,EAAMgC,MAAAA,gBAMvCxB,EAAOI,SAAW,CAChBU,MAAO,EACPkB,QA7Fc,SAACM,UAAMC,mBAAmBC,OAAOF,GAAGG,OAAOC,cAAcC,QAAQ,OAAQ,OA8FvFV,qBAAsB,EACtBE,WAAW,EACXC,gBApFsB,SAAC5C,EAAMU,EAAMM,EAAOoC,SAGpCC,EAAa,CACjBzD,OAAOe,OAAO,IAAIK,EAAMsC,MAAM,YAAa,IAAK,GAAI,CAClDC,gBACM7C,EAAK8C,eAAiB,CAAC,CAAC,QAAS9C,EAAK8C,iBAAmB,IAC7D,CAAC,OAAQ9C,EAAK+C,cAAczD,EAAMgB,KAC/BpB,OAAO8D,QAAQhD,EAAKiD,eAAe3D,EAAMgB,OAGhDpB,OAAOe,OAAO,IAAIK,EAAMsC,MAAM,aAAc,GAAI,GAAI,CAAEhB,QAAS5B,EAAKkD,kBACpE,IAAI5C,EAAMsC,MAAM,aAAc,KAAM,IAKlC5C,EAAKmD,gBACPR,EAAW7D,GAAUkB,EAAKoD,kBAjBRlE,OAAOe,OAAO,IAAIK,EAAMsC,MAAM,OAAQ,GAAI,GAAI,CAAEhB,QAAS,UAmB7EtB,EAAME,OAAOkC,EAAM,GAAGlB,UAAS1C,EAASkB,EAAKoD,0BAAqBT,IAiElEG,eAAgB,gBAChBK,gBAAgB,EAChBD,gBAAiB,IACjBE,iBAAiB,EACjBL,cA5FoB,SAAAzD,aAAYA,GA6FhC2D,eA5FqB,SAAA3D,SAAS"}